auto loadable = params[0].as<NodeLoadable*>();  

auto self = loadable->cast<Scene>();

auto& gs = self->getDataRef("game_state").v<sp<GameState>>();
auto& gd = self->getDataRef("game_data" ).v<sp<GameData >>();


// apply tiles
for (auto& t : gd->tiles)
  t->is_drawable_self(false);

for (byte y=0; y<gs->board_h; ++y) {
  for (byte x=0; x<gs->board_w; ++x) {
    byte idx = y * gs->board_w + x;
    auto t = gd->tiles[idx];
    t->callFunc("select", {Var(to_string(((x%2) + (y%2))%2))});
    t->position({
        (x - (gs->board_w - 1) * REAL(0.5)) * gd->tile_w,
        (y - (gs->board_h - 1) * REAL(0.5)) * gd->tile_w,
        REAL(0.0)
    });

    auto is_on_edge = x == 0 || y == 0 || x == gs->board_w-1 || y == gs->board_h-1;
    likely (gs->need_tile_show_action == false || is_on_edge == false)
      t->is_drawable_self(true);
    else
      t->setAction("show");
  }
}


// apply walls
for (auto& w : gd->walls)
  w->is_drawable_self(false);

for (size_t wi=0; wi<gs->wall_poses.size(); ++wi) {
  auto& wp = gs->wall_poses[wi];
  auto& w = gd->walls[wi];
  w->position({
      (wp.x - (gs->board_w - 1) * REAL(0.5)) * gd->tile_w,
      (wp.y - (gs->board_h - 1) * REAL(0.5)) * gd->tile_w,
      REAL(0.0)
  });
  w->is_drawable_self(true);
}


// update ui
self->callFunc("updateUi", {});
return null_var;
