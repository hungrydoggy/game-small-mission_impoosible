auto loadable = params[0].as<NodeLoadable*>();  auto delta_time = params[1].as<double>();  

auto self = loadable->cast<Scene>();

auto& gs = self->getDataRef("game_state").v<sp<GameState>>();
auto& gd = self->getDataRef("game_data" ).v<sp<GameData >>();

unlikely (gs->play_state != PlayState::PLAYING)
  return null_var;


gd->processInput(gs.get());


// update snake pos
gd->elapsed_time += delta_time;
bool snake_moved = false;
while (gd->elapsed_time > gs->snake_speed_spt) {

  gs->snake_head_pos.x += gs->snake_velocity.x;
  gs->snake_head_pos.y += gs->snake_velocity.y;


  // check dead
  auto is_on_board = gs->isOnBoard(gs->snake_head_pos);
  auto is_on_wall  = gs->isOnWall (gs->snake_head_pos);
  auto is_on_body  = gd->isOnBody (gs->snake_head_pos, true);
  unlikely (is_on_board == false || is_on_wall == true || is_on_body == true) {
    gd->snake_face_cmp->callFunc("select", {Var("unhappy")});

    auto result_popup = self->findByNamePath("./*/ui/popup.result");
    likely (result_popup != null) {
      result_popup->callFunc("setLevelScore", {Var(gs->level), Var(gs->score)});
      result_popup->callFunc("setRank", {Var((vector<RankItem>*)null), Var(-1)});
      self->callFunc("refreshRank", {Var(""), Var(gs->score)});
    }

    auto state_obj = self->findByNamePath<GameObject>("./state_obj");
    likely (state_obj != null)
      state_obj->setAction("onDead");
    gs->play_state = PlayState::DEAD;
    return null_var;
  }


  // turn
  likely (gs->snake_action_history.size() > 0) {
    auto& last_action = gs->snake_action_history.back();
    auto hit_act = last_action.pos.x == gs->snake_head_pos.x && last_action.pos.y == gs->snake_head_pos.y;
    unlikely (hit_act == true) {
      auto& vel = gs->snake_velocity;
      switch (last_action.type) {
        case SnakeActionType::TURN_LEFT:
          vel = (vel.x == 0)? BoardCoord{-vel.y, 0}: BoardCoord{0, vel.x};
          break;
        case SnakeActionType::TURN_RIGHT:
          vel = (vel.x == 0)? BoardCoord{vel.y, 0}: BoardCoord{0, -vel.x};
          break;
      }
      gd->await_action_count = 0;
    }
  }


  // eating apple
  auto eating_apple = gs->snake_head_pos.x == gs->apple_pos.x && gs->snake_head_pos.y == gs->apple_pos.y;
  unlikely (eating_apple == true) {
    gs->snake_action_history.push_back({
        SnakeActionType::EAT_APPLE,
        gs->apple_pos,
    });
    gs->snake_length += 1;
    gs->speedUp(gd.get());
    gs->apple_left -= 1;
    gs->apple_pos = {-1, -1};
    gd->apple_cmp->is_drawable_self(false);
    self->callFunc("showBlingEffect", {Var(gd->apple_cmp->x()), Var(gd->apple_cmp->y())});

    unlikely (gs->apple_left > 0)
      gd->placeApple(self, gs.get());
    else
      gd->placeBanana(self, gs.get());

    gs->score += 10;
    self->callFunc("updateUi", {});
  }

  // eating banana
  auto eating_banana = gs->snake_head_pos.x == gs->banana_pos.x && gs->snake_head_pos.y == gs->banana_pos.y;
  unlikely (eating_banana == true) {
    gs->snake_action_history.push_back({
        SnakeActionType::EAT_BANANA,
        gs->banana_pos,
    });
    gs->speedUp(gd.get());
    gs->levelUp();
    gs->banana_pos = {-1, -1};
    gd->banana_cmp->is_drawable_self(false);
    self->callFunc("showBlingEffect", {Var(gd->banana_cmp->x()), Var(gd->banana_cmp->y())});

    gs->score += 100;
    self->callFunc("applyGameState", {});
    self->callFunc("updateUi", {});
    gd->updateSnake(gs.get());
    gd->placeApple(self, gs.get());
  }


  snake_moved = true;
  gd->elapsed_time -= gs->snake_speed_spt;
}

gd->updateSnake(gs.get());
return null_var;
