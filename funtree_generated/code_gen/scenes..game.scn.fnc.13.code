

sp<fun_tree::Content> GameState::convertToMap () {

  auto paw = make_shared<PawPrint>("game_state");
  paw->beginMap();
  paw->endMap();


  return fun_tree::PawPrintParser::parse(PawPrint::root(paw));
}


void GameState::setByMap (sp<fun_tree::Content> const& map) {
  unlikely (map == null || map->type() != Content::Type::MAP) {
    LOG("[warn]  state of GameState must be a Map");
    return;
  }
  auto state = dpc<Map>(map);

}


bool GameState::isOnWall (BoardCoord const& pos) {
  for (auto& wp : wall_poses) {
    auto overlaped = wp.x == pos.x && wp.y == pos.y;
    unlikely (overlaped == true)
      return true;
  }

  return false;
}


void GameState::speedUp (GameData* gd) {
  auto elapsed_ratio = gd->elapsed_time / snake_speed_spt;
  snake_speed_spt = math::max(snake_min_speed_spt, snake_speed_spt / snake_acc_spt);
  gd->elapsed_time = elapsed_ratio * snake_speed_spt;
}


void GameState::levelUp () {

  // make wall
  likely (isOnBoard(banana_pos) == true)
    wall_poses.push_back(banana_pos);

  // move pos infos for expanding board
  auto old_w = board_w;
  auto old_h = board_h;
  board_w = math::min(11, board_w + 2);
  board_h = math::min(11, board_h + 2);

  auto delta_w = (board_w - old_w) / 2;
  auto delta_h = (board_h - old_h) / 2;
  snake_head_pos.x += delta_w;
  snake_head_pos.y += delta_h;
  for (auto& sa : snake_action_history) {
    sa.pos.x += delta_w;
    sa.pos.y += delta_h;
  }
  for (auto& wp : wall_poses) {
    wp.x += delta_w;
    wp.y += delta_h;
  }

  level += 1;
  apple_left = level;

  need_tile_show_action = delta_w != 0 || delta_h != 0;
}


void GameData::processInput (GameState* gs) {
  // process input
  likely (gs->snake_action_history.size() > 0) {
    auto& last_action = gs->snake_action_history.back();
    auto already_act =
           last_action.pos.x == gs->snake_head_pos.x + gs->snake_velocity.x
        && last_action.pos.y == gs->snake_head_pos.y + gs->snake_velocity.y;
    unlikely (already_act == true)
      return;
  }

  static vector<KeyEventType> keys_for_turn =
      {KeyEventType::KEY_LEFT, KeyEventType::KEY_UP, KeyEventType::KEY_RIGHT, KeyEventType::KEY_DOWN};
  int dir_idx = gs->getSnakeDirIdx();  // up, right, down, left
  auto left_turn_key  = keys_for_turn[dir_idx];
  auto right_turn_key = keys_for_turn[(dir_idx + 2) % 4];

  if (last_key_type == left_turn_key) {
    gs->snake_action_history.push_back({
        SnakeActionType::TURN_LEFT,
        {gs->snake_head_pos.x + gs->snake_velocity.x, gs->snake_head_pos.y + gs->snake_velocity.y},
    });
    await_action_count = 1;
    last_key_type = KeyEventType::KEY_NONE;
  }else if (last_key_type == right_turn_key) {
    gs->snake_action_history.push_back({
        SnakeActionType::TURN_RIGHT,
        {gs->snake_head_pos.x + gs->snake_velocity.x, gs->snake_head_pos.y + gs->snake_velocity.y},
    });
    await_action_count = 1;
    last_key_type = KeyEventType::KEY_NONE;
  }
}


static void __updateVelByActionHistory (
    size_t& history_idx_from_top,
    BoardCoord const& cur_pos,
    BoardCoord& vel,
    vector<SnakeAction> const& snake_action_history
) {
  unlikely (history_idx_from_top >= snake_action_history.size())
    return;

  auto& snake_action = snake_action_history[snake_action_history.size() - history_idx_from_top - 1];
  auto has_action = cur_pos.x == snake_action.pos.x && cur_pos.y == snake_action.pos.y;
  likely (has_action == false)
    return;

  switch (snake_action.type) {
    case SnakeActionType::TURN_LEFT:
      vel = (vel.x == 0)? BoardCoord{vel.y, 0}: BoardCoord{0, -vel.x};
      break;

    case SnakeActionType::TURN_RIGHT:
      vel = (vel.x == 0)? BoardCoord{-vel.y, 0}: BoardCoord{0, vel.x};
      break;

    case SnakeActionType::EAT_APPLE:
      break;
  }

  history_idx_from_top += 1;

  return __updateVelByActionHistory(history_idx_from_top, cur_pos, vel, snake_action_history);
}


void GameData::updateSnake (GameState* gs) {
  const real kSnakeZPerBody = REAL( 0.1);
  const real kSnakeTailSclY = REAL( 0.5);
  const int kSnakeBodyCntPerTile = 4;

  real elapsed_ratio = (real)(elapsed_time / gs->snake_speed_spt);

  snake_body_poses.clear();


  { // snake face
    auto tile_idx = gs->snake_head_pos.y * gs->board_w + gs->snake_head_pos.x;
    auto t = tiles[tile_idx];
    snake_face_cmp->position({
        t->x() + tile_w * gs->snake_velocity.x * elapsed_ratio,
        t->y() + tile_w * gs->snake_velocity.y * elapsed_ratio,
        REAL(0.0),
    });
    snake_body_poses.push_back(gs->snake_head_pos);
    
    auto scl_x = snake_face_cmp->scale().x();
    if (gs->snake_velocity.x > 0)
      scl_x = REAL(-1.0);
    else if (gs->snake_velocity.x < 0)
      scl_x = REAL(1.0);
    snake_face_cmp->scale({scl_x, REAL(1.0), REAL(1.0)});

    snake_face_cmp->callFunc("select", {Var("happy")});
  }


  int total_body_cnt = gs->snake_length * kSnakeBodyCntPerTile - 1;
  { // snake bodies
    // hide all bodies
    for (auto& b : snake_bodies)
      b->is_drawable_self(false);

    // apply bodies
    size_t history_idx_from_top = await_action_count;
    BoardCoord vel = gs->snake_velocity;
    BoardCoord prev_vel = vel;
    __updateVelByActionHistory(history_idx_from_top, gs->snake_head_pos, vel, gs->snake_action_history);
    BoardCoord cur_pos = {gs->snake_head_pos.x - vel.x, gs->snake_head_pos.y - vel.y};
    BoardCoord prev_pos = gs->snake_head_pos;

    for (byte si=1; si<gs->snake_length; ++si) {

      unlikely (gs->isOnBoard(cur_pos) == false)
        break;

      snake_body_poses.push_back(cur_pos);

      // ready
      auto prev_tile_idx = prev_pos.y * gs->board_w + prev_pos.x;
      auto prev_tile = tiles[prev_tile_idx];

      auto tile_idx = cur_pos.y * gs->board_w + cur_pos.x;
      auto tile = tiles[tile_idx];
      
      // set bodies
      for (int bi=(si-1)*kSnakeBodyCntPerTile; bi<si*kSnakeBodyCntPerTile; ++bi) {
        auto& b = snake_bodies[bi];

        auto bi_ratio = REAL(1.0) - (((bi % kSnakeBodyCntPerTile)+1) / (real)kSnakeBodyCntPerTile) + elapsed_ratio;
        if (bi_ratio > REAL(1.0)) {
          // case: use prev
          bi_ratio -= REAL(1.0);
          b->position({
            tile_w * prev_vel.x * bi_ratio + prev_tile->x(),
            tile_w * prev_vel.y * bi_ratio + prev_tile->y(),
            REAL(0.0),
          });
        }else {
          // case: use cur
          b->position({
            tile_w * vel.x * bi_ratio + tile->x(),
            tile_w * vel.y * bi_ratio + tile->y(),
            REAL(0.0),
          });
        }
        //auto scl = (REAL(1.0) - kSnakeTailSclY) * (total_body_cnt-bi-1) / (real)(total_body_cnt-1) + kSnakeTailSclY;
        auto scl = REAL(1.0);
        b->getChild(0)->scale({
            scl,
            scl,
            REAL(1.0),
        });
        b->is_drawable_self(true);
      }


      // check has action and rotate
      prev_vel = vel;
      __updateVelByActionHistory(history_idx_from_top, cur_pos, vel, gs->snake_action_history);

      prev_pos = cur_pos;
      cur_pos = {cur_pos.x - vel.x, cur_pos.y - vel.y};
    }
  }


  { // set z values
    // sort by tail-to-head
    vector<GameComponent*> tail_to_head_bodies;
    for (int bi=total_body_cnt-1; bi>=0; --bi)
      tail_to_head_bodies.push_back(snake_bodies[bi]);

    // sort by desc y
    vector<GameComponent*> sorted_bodies;
    while (sorted_bodies.size() < tail_to_head_bodies.size()) {
      real max_y = REAL(-100000.0);
      size_t idx_of_max = 0;
      for (size_t ti=0; ti<tail_to_head_bodies.size(); ++ti) {
        auto& bd = tail_to_head_bodies[ti];
        unlikely (bd == null)
          continue;

        unlikely (max_y < bd->y()) {
          max_y = bd->y();
          idx_of_max = ti;
        }
      }

      sorted_bodies.push_back(tail_to_head_bodies[idx_of_max]);
      tail_to_head_bodies[idx_of_max] = null;
    }

    // set bodies.z
    real z = REAL(0.0);
    for (auto& bd : sorted_bodies) {
      bd->z(z);
      z += kSnakeZPerBody;
    }

    // set face.z
    snake_face_cmp->z(z);
  }
}


bool GameData::isOnBody (BoardCoord const& pos, bool skip_tail/*=*/) {

  size_t body_size = snake_body_poses.size();
  unlikely (skip_tail == true)
    body_size -= 1;

  for (size_t si=0; si<body_size; ++si) {
    auto& bp = snake_body_poses[si];
    auto overlaped = bp.x == pos.x && bp.y == pos.y;
    unlikely (overlaped == true)
      return true;
  }

  return false;
}


static BoardCoord __findPlace (GameState* gs, GameData* gd) {
  unlikely (gs->snake_length >= gs->board_w*gs->board_h)
    return {-1, -1};

  // find pos to place
  while (true) {
    BoardCoord pos = {
        DefaultRandomPocket::draw(0, gs->board_w - 1),
        DefaultRandomPocket::draw(0, gs->board_h - 1),
    };

    auto is_on_wall = gs->isOnWall(pos);
    unlikely (is_on_wall == true)
      continue;

    auto is_on_body = gd->isOnBody(pos);
    unlikely (is_on_body == true)
      continue;

    return pos;
  }

  return {-1, -1};
}


void GameData::placeApple (Scene* scene, GameState* gs) {
  gs->apple_pos = __findPlace(gs, this);

  auto has_apple_on_board = gs->isOnBoard(gs->apple_pos);
  likely (has_apple_on_board == true) {
    byte idx = gs->apple_pos.y * gs->board_w + gs->apple_pos.x;
    auto t = tiles[idx];
    apple_cmp->position({t->x(), t->y(), REAL(0.0)});
    apple_cmp->findChild<GameObject>("txt")->setText(to_string(gs->apple_left));
    apple_cmp->setAction("show");

  }else {
    apple_cmp->is_drawable_self(false);
  }

}


void GameData::placeBanana (Scene* scene, GameState* gs) {
  gs->banana_pos = __findPlace(gs, this);

  auto has_banana_on_board = gs->isOnBoard(gs->banana_pos);
  likely (has_banana_on_board == true) {
    byte idx = gs->banana_pos.y * gs->board_w + gs->banana_pos.x;
    auto t = tiles[idx];
    banana_cmp->position({t->x(), t->y(), REAL(0.0)});
    banana_cmp->setAction("show");

  }else {
    banana_cmp->is_drawable_self(false);
  }
}