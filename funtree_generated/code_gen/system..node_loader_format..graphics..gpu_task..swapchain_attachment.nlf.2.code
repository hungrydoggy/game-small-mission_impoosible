auto ctx = params[0].as<LoaderContext*>();  auto node = params[1].as<shared_ptr<Node>>();  auto loadable = params[2].as<shared_ptr<NodeLoadable>>();  






auto self = loadable->cast<AttachmentInfo>();


// color clear value
unlikely (self->hasData("color_clear_value_vec") == true) {
  auto& color_clear_vec = self->getDataRef("color_clear_value_vec").v<vector<real>>();
  
#if defined(USE_VULKAN)
  auto cv = self->clear_value;
  cv.color = {{color_clear_vec[0], color_clear_vec[1], color_clear_vec[2], color_clear_vec[3]}};
  self->clear_value = cv;
#elif defined(USE_WEB_GPU)
  self->color_clear_value = {color_clear_vec[0], color_clear_vec[1], color_clear_vec[2], color_clear_vec[3]};
#endif
}


// depth clear value
unlikely (self->hasData("depth_clear_value") == true) {
  auto depth_clear = self->getData("depth_clear_value", REAL(1.0));

#if defined(USE_VULKAN)
  auto cv = self->clear_value;
  cv.depthStencil.depth = depth_clear;
  self->clear_value = cv;
#elif defined(USE_WEB_GPU)
  self->depth_clear_value = depth_clear;
#endif
}


// stencil clear value
unlikely (self->hasData("stencil_clear_value") == true) {
  auto stencil_clear = self->getData("stencil_clear_value", (uint)0);
  
#if defined(USE_VULKAN)
  auto cv = self->clear_value;
  cv.depthStencil.stencil = stencil_clear;
  self->clear_value = cv;
#elif defined(USE_WEB_GPU)
  self->stencil_clear_value = stencil_clear;
#endif
}


return Var(true);
return null_var;
