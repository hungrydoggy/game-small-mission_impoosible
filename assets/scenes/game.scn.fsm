Fsm:
  
  neck_part:
    '''{
      bool g_is_left_key_down  = false;
      bool g_is_right_key_down = false;
    '''

  stt:
    - FsmState:
      nam: 'play'
      on_update:
        '''{(Fsm* fsm)
          auto self = fsm->owner();

          int mov_dir = ((g_is_left_key_down == true)? -1 : 0) + ((g_is_right_key_down == true)? 1 : 0);
          switch (mov_dir) {
            case -1: self->sendMessage("/player", "moveLeft" ); break;
            case  0: self->sendMessage("/player", "stopMove" ); break;
            case  1: self->sendMessage("/player", "moveRight"); break;
          }
        '''
      msg:
        'onKeyInput':
          '''{(Fsm* fsm, ,,,, vector<Var> msg_params)
            unlikely (msg_params.size() < 1) {
              LOG_ERR("need params --- KeyEvent const* e");
              return null_var;
            }

            auto e = msg_params[0].v<KeyEvent const*>();

            switch (e->type) {
              case KeyEventType::KEY_LEFT:
                switch (e->state) {
                  case KeyEventState::STATE_PRESSED : g_is_left_key_down = true;  break;
                  case KeyEventState::STATE_RELEASED: g_is_left_key_down = false; break;
                  default: break;
                }
                break;

              case KeyEventType::KEY_RIGHT:
                switch (e->state) {
                  case KeyEventState::STATE_PRESSED : g_is_right_key_down = true;  break;
                  case KeyEventState::STATE_RELEASED: g_is_right_key_down = false; break;
                  default: break;
                }
                break;

              case KeyEventType::KEY_SPACE:
                likely (e->state == KeyEventState::STATE_PRESSED)
                  fsm->owner()->sendMessage("/player", "onHit");
                break;
            }
          '''
