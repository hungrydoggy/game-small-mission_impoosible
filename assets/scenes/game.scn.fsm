Fsm:

  include_part:
    '''{
      #include <plugins/cooldown/cooldown.h>
      #include <plugins/cooldown/cooldown_manager.h>
    '''
  
  neck_part:
    '''{
      using namespace appetizer;


      bool g_is_left_key_down  = false;
      bool g_is_right_key_down = false;

      StringRegistryIdType g_cooldown_manager_gid = StringRegistry::default_registry().lookUp("cooldown_manager");

      StringRegistryIdType g_poop_create_interval_reg = StringRegistry::default_registry().lookUp("poop_create_interval");


      static void __makePoop (GameObject* self, real x);
    '''

  stt:
    - FsmState:
      nam: 'play'
      on_update:
        '''{(Fsm* fsm)
          auto self = fsm->owner();


          // process input
          int mov_dir = ((g_is_left_key_down == true)? -1 : 0) + ((g_is_right_key_down == true)? 1 : 0);
          switch (mov_dir) {
            case -1: self->sendMessage("/player", "moveLeft" ); break;
            case  0: self->sendMessage("/player", "stopMove" ); break;
            case  1: self->sendMessage("/player", "moveRight"); break;
          }


          // create poops
          auto cooldown_manager = self->getTrait<CooldownManager>(g_cooldown_manager_gid);
          auto cooldown = cooldown_manager->getCooldown(g_poop_create_interval_reg);
          unlikely (cooldown->is_complete() == true) {
            auto x = DefaultRandomPocket::draw(
                self->scene()->getData("bound.left" , REAL(0.0)),
                self->scene()->getData("bound.right", REAL(0.0))
            );
            __makePoop(self, x);
            cooldown->start();
          }
        '''
      msg:
        'onKeyInput':
          '''{(Fsm* fsm, ,,,, vector<Var> msg_params)
            unlikely (msg_params.size() < 1) {
              LOG_ERR("need params --- KeyEvent const* e");
              return null_var;
            }

            auto e = msg_params[0].v<KeyEvent const*>();

            switch (e->type) {
              case KeyEventType::KEY_LEFT:
                switch (e->state) {
                  case KeyEventState::STATE_PRESSED : g_is_left_key_down = true;  break;
                  case KeyEventState::STATE_RELEASED: g_is_left_key_down = false; break;
                  default: break;
                }
                break;

              case KeyEventType::KEY_RIGHT:
                switch (e->state) {
                  case KeyEventState::STATE_PRESSED : g_is_right_key_down = true;  break;
                  case KeyEventState::STATE_RELEASED: g_is_right_key_down = false; break;
                  default: break;
                }
                break;

              case KeyEventType::KEY_SPACE:
                likely (e->state == KeyEventState::STATE_PRESSED) {
                  auto heart = fsm->owner()->findByNamePath<GameObject>("/hearts/0");
                  heart->y(200);
                  heart->alpha(1);
                  heart->scale({1, 1, 1});
                  heart->activate();
                }
                break;
            }
          '''

  hip_part:
    '''{

      static GameComponent* __pickInactivePoop (GameObject* self) {
        auto poop_parent = self->findByNamePath("/poops.normal");

        for (auto& poop : poop_parent->children()) {
          unlikely (poop->getData("is_active", false) == false)
            return poop.get();
        }

        return null;
      }


      void __makePoop (GameObject* self, real x) {
        auto poop = __pickInactivePoop(self);
        unlikely (poop == null)
          return;

        poop->x(x);
        poop->y(0);
        self->sendMessage(poop, "setActive", {Var(true)});
      }
    '''
