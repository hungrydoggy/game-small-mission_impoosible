ObjectFormat:
  full_name: 'VatComponentStateSerializer'
  short_name: 'VatComponentSttSer'
  aliases: ['VatCmpSttSer']
  groups: ['StateSerializerGroup']
  include_part:
    '''{
      #include <common/state_serializer/state_serializer.h>
    '''
  loadable_class: 'StateSerializerNodeLoadable'
  post_load:
    '''{(
          LoaderContext* ctx,
          shared_ptr<Node> node,
          shared_ptr<NodeLoadable> loadable,
        )
      auto self = loadable->cast<StateSerializerNodeLoadable>();

      self->on_serialize_func =
          [](GameComponent* cmp, string const& name, vector<byte>& buffer) {
            auto vat_cmp = dynamic_cast<VATComponent*>(cmp);
            unlikely (vat_cmp == null) {
              LOG_ERR("need VATComponent --- %s", cmp->makePath().c_str());
              return false;
            }

            Serializer::serializeByAuto((byte)vat_cmp->is_over          (), buffer);
            Serializer::serializeByAuto((byte)vat_cmp->is_blend_mode    (), buffer);
            Serializer::serializeByAuto(      vat_cmp->left_repeat_count(), buffer);
            Serializer::serializeByAuto(      vat_cmp->selected_name    (), buffer);
            Serializer::serializeByAuto((real)vat_cmp->progress         (), buffer);

            auto interp_state = vat_cmp->interp_state();
            Serializer::serializeByAuto((byte)(vat_cmp->interp_state() != null), buffer);

            unlikely (interp_state != null) {
              auto sel = vat_cmp->findFirstSelector();
              auto interp_state_old_state_selected_name = sel->findStateName(interp_state->old_state.get());
              Serializer::serializeByAuto(      interp_state_old_state_selected_name, buffer);
              Serializer::serializeByAuto((real)interp_state->old_state->progress() , buffer);
              Serializer::serializeByAuto((real)interp_state->elapsed , buffer);
              Serializer::serializeByAuto((real)interp_state->duration, buffer);
            }

            return true;
          };

      self->on_deserialize_func =
          [](GameComponent* cmp, string const& name, byte const*& buffer) {
            auto vat_cmp = dynamic_cast<VATComponent*>(cmp);
            unlikely (vat_cmp == null) {
              LOG_ERR("need VATComponent --- %s", cmp->makePath().c_str());
              return false;
            }

            byte   is_over;            Serializer::deserializeByAuto(is_over          , buffer);
            byte   is_blend_mode;      Serializer::deserializeByAuto(is_blend_mode    , buffer);
            ushort left_repeat_count;  Serializer::deserializeByAuto(left_repeat_count, buffer);
            string selected_name;      Serializer::deserializeByAuto(selected_name    , buffer);
            real   progress;           Serializer::deserializeByAuto(progress         , buffer);

            byte has_interp_state;  Serializer::deserializeByAuto(has_interp_state, buffer);

            string interp_state_old_state_selected_name;
            real   interp_state_old_state_progress;
            real   interp_state_elapsed;
            real   interp_state_duration;
            unlikely (has_interp_state == true) {
              Serializer::deserializeByAuto(interp_state_old_state_selected_name, buffer);
              Serializer::deserializeByAuto(interp_state_old_state_progress     , buffer);
              Serializer::deserializeByAuto(interp_state_elapsed , buffer);
              Serializer::deserializeByAuto(interp_state_duration, buffer);
            }

            vat_cmp->setByForce(
                is_over,
                is_blend_mode,
                left_repeat_count,
                selected_name,
                progress,
                has_interp_state,
                interp_state_old_state_selected_name,
                interp_state_old_state_progress,
                interp_state_elapsed,
                interp_state_duration
            );

            return true;
          };

      return Var(true);
    '''
  attributes:
    - AttributeFormat:
      full_name: 'name'
      short_name: 'nam'
      is_essential: false
      formats:
        - ValueFormat:
          type: 'Value'
          sub_type: 'string'
          on_load:
            '''{(
                  FormatContext* ctx,
                  shared_ptr<NodeLoadable> loadable,
                  shared_ptr<Node> node,
                  shared_ptr<Content> content
                )

              auto self = loadable->cast<StateSerializerNodeLoadable>();
              self->name = content->asValue<string>();
              return Var(true);
            '''
