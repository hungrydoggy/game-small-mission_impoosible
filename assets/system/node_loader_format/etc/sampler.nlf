ObjectFormat:
  full_name: 'Sampler'
  include_part:
    '''{
      #include <resource/sampler/sampler.h>
    '''
  loadable_class: 'Sampler'
  attributes:
    - AttributeFormat:
      full_name: 'mag_filter'
      short_name: 'mgf'
      is_essential: false
      formats:
        - ValueFormat:
          type: 'Value'
          sub_type: 'string'
          on_load:
            '''{(
                  FormatContext* ctx,
                  shared_ptr<NodeLoadable> loadable,
                  shared_ptr<Node> node,
                  shared_ptr<Content> content
                )

              string mgf_str = content->cast<Value>()->var().as<string>();
              Util::upper(mgf_str);

              auto mgf_p = Util::find(Sampler::filter_enm_map(), mgf_str);
              auto self = loadable->cast<Sampler>();
              self->mag_filter((mgf_p != null)? *mgf_p : Sampler::Filter::LINEAR);
              return Var(true);
            '''
    - AttributeFormat:
      full_name: 'min_filter'
      short_name: 'mnf'
      is_essential: false
      formats:
        - ValueFormat:
          type: 'Value'
          sub_type: 'string'
          on_load:
            '''{(
                  FormatContext* ctx,
                  shared_ptr<NodeLoadable> loadable,
                  shared_ptr<Node> node,
                  shared_ptr<Content> content
                )

              string mnf_str = content->cast<Value>()->var().as<string>();
              Util::upper(mnf_str);

              auto mnf_p = Util::find(Sampler::filter_enm_map(), mnf_str);
              auto self = loadable->cast<Sampler>();
              self->min_filter((mnf_p != null)? *mnf_p : Sampler::Filter::LINEAR);
              return Var(true);
            '''
    - AttributeFormat:
      full_name: 'wrap_s'
      short_name: 'wrs'
      is_essential: false
      formats:
        - ValueFormat:
          type: 'Value'
          sub_type: 'string'
          on_load:
            '''{(
                  FormatContext* ctx,
                  shared_ptr<NodeLoadable> loadable,
                  shared_ptr<Node> node,
                  shared_ptr<Content> content
                )

              string wrs_str = content->cast<Value>()->var().as<string>();
              Util::upper(wrs_str);

              auto wrs_p = Util::find(Sampler::wrap_enm_map(), wrs_str);
              auto self = loadable->cast<Sampler>();
              self->wrap_s((wrs_p != null)? *wrs_p : Sampler::WrapOption::CLAMP_TO_EDGE);
              return Var(true);
            '''
    - AttributeFormat:
      full_name: 'wrap_t'
      short_name: 'wrt'
      is_essential: false
      formats:
        - ValueFormat:
          type: 'Value'
          sub_type: 'string'
          on_load:
            '''{(
                  FormatContext* ctx,
                  shared_ptr<NodeLoadable> loadable,
                  shared_ptr<Node> node,
                  shared_ptr<Content> content
                )

              string wrt_str = content->cast<Value>()->var().as<string>();
              Util::upper(wrt_str);

              auto wrt_p = Util::find(Sampler::wrap_enm_map(), wrt_str);
              auto self = loadable->cast<Sampler>();
              self->wrap_t((wrt_p != null)? *wrt_p : Sampler::WrapOption::CLAMP_TO_EDGE);
              return Var(true);
            '''
    - AttributeFormat:
      full_name: 'mip_levels'
      short_name: 'mip'
      is_essential: false
      formats:
        - ValueFormat:
          type: 'Value'
          sub_type: 'number'
          on_load:
            '''{(
                  FormatContext* ctx,
                  shared_ptr<NodeLoadable> loadable,
                  shared_ptr<Node> node,
                  shared_ptr<Content> content
                )

              auto self = loadable->cast<Sampler>();
              self->mip_levels(content->cast<Value>()->var().as<uint>());

              return Var(true);
            '''
    - AttributeFormat:
      full_name: 'compare_enable'
      short_name: 'cmp'
      is_essential: false
      formats:
        - ValueFormat:
          type: 'Value'
          sub_type: 'bool'
          on_load:
            '''{(
                  FormatContext* ctx,
                  shared_ptr<NodeLoadable> loadable,
                  shared_ptr<Node> node,
                  shared_ptr<Content> content
                )

              auto self = loadable->cast<Sampler>();
              self->compare_enable(content->cast<Value>()->var().as<bool>());

              return Var(true);
            '''
