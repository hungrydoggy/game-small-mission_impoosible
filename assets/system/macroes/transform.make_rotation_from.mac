MacroFormat:
  full_name: 'Transform.makeRotationFrom'
  short_name: 'trans.rotFrom'
  include_part: '{#include <game_component/game_component.h>'
  formats:
    - MapFormat:
      attributes:
        - AttributeFormat:
          full_name: 'source_target'
          short_name: 'src'
          is_essential: true
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = loadable->cast<Macro>();
                  self->params.set(0, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'source_rotation'
          short_name: 'rot'
          is_essential: true
          formats:
            - '@system/node_loader_format/common/quaternion.nlf':
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = loadable->cast<Macro>();
                  self->params.set(1, make_shared<Value>(ctx->getData("quaternion.val"), content));
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'destination_target'
          short_name: 'dst'
          is_essential: false
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(2, content);
                  return Var(true);
                '''
  on_call:
    '''{(
          shared_ptr<Node> node,
          shared_ptr<Content> content,
          shared_ptr<Macro> self
        )

      auto& mac_params = self->params;

      // get params
      auto src_path = mac_params.get(0)->asValue<string>();
      auto rot      = mac_params.get(1)->asValue<Quaternion>();
      auto dst_path = KV(".", mac_params.get(2), template asValue<string>());


      // make MacroOnLoad
      auto macro_on_load =
          make_shared<MacroOnLoad>(
            [content](LoaderContext& ctx, shared_ptr<Node> const& node)->bool {
              return true;
            },
            [content, src_path, rot, dst_path](LoaderContext& ctx, shared_ptr<Node> const& node)->sp<Content> {
              // ready
              auto owner_node = node->findAncestorNodeByObjectName("GameComponentGroup", ctx.node_loader_bundle);
              unlikely (owner_node == null) {
                CNT_LOG_ERR(content, "this macro must have an owner component (GameComponentGroup in its ancestry).");
                return null;
              }

              auto cmp = dpc<GameComponent>(ctx.node_loadable_map->at(owner_node.get()));
              unlikely (cmp == null) {
                CNT_LOG_ERR(content, "owner component loadable is null");
                return null;
              }

              auto src = cmp->findByNamePath(src_path);
              unlikely (src == null) {
                CNT_LOG_ERR(content, "cannot find src path --- %s", src_path.c_str());
                return null;
              }

              auto dst = cmp->findByNamePath(dst_path);
              unlikely (dst == null) {
                CNT_LOG_ERR(content, "cannot find dst path --- %s", dst_path.c_str());
                return null;
              }


              // make result
              auto dst_rot =
                  (
                    dst->inv_model_matrix()
                    * src->model_matrix()
                    * Matrix::makeRotate(rot)
                  ).extractRotation();
              auto result =
                  make_shared<Sequence>(content->file_path(), content->line_in_file(), content->column_in_file());
              result->add(make_shared<Value>(Var(dst_rot.x()), content));
              result->add(make_shared<Value>(Var(dst_rot.y()), content));
              result->add(make_shared<Value>(Var(dst_rot.z()), content));
              result->add(make_shared<Value>(Var(dst_rot.w()), content));


              return result;
            },
            content->file_path(),
            content->line_in_file(),
            content->column_in_file()
          );

      return Var(macro_on_load);
    '''
