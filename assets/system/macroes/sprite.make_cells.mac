MacroFormat:
  full_name: 'Sprite.makeCellsBySheet'
  short_name: 'sprite.makeCellsBySheet'
  aliases: ['sprite.cellsBySheet']
  include_part:
    '''{
      #include <game_component/object/game_object.h>
      #include <view/image_view/image_view_def.h>
      #include <view/sprite_view/sprite_view_def.h>
      #include <view/view.h>
    '''

  neck_part:
    '''{
      using namespace appetizer;
      using namespace appetizer::fun_tree;


      namespace {
        class CellIndexIterator_ {
        public: // inner types
          enum class ContentType {
            DEFAULT,
            COUNT,
            INDEX_LIST,
          };


        public: // methods
          CellIndexIterator_ (sp<Content> const& cont, uint row_cnt, uint col_cnt);

          int step ();

          size_t size () const;


        private: // vars
          sp<Content> content_;

          ContentType content_type_;
          size_t next_idx_;
          vector<int> index_list_;
        };



        class CellDurFrmIterator_ {
        public: // inner types
          enum class ContentType {
            DEFAULT,
            FRAME,
            FRAME_LIST,
          };


        public: // methods
          CellDurFrmIterator_ (sp<Content> const& cont, size_t cell_cnt);

          uint step ();


        private: // vars
          sp<Content> content_;

          ContentType content_type_;
          size_t next_idx_;
          vector<uint> frame_list_;
        };
      }
    '''

  formats:
    - MapFormat:
      attributes:
        - AttributeFormat:
          full_name: 'sheet_texture_path'
          short_name: 'tex'
          is_essential: true
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(0, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'row_count'
          short_name: 'row'
          is_essential: true
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'number'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(1, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'col_count'
          short_name: 'col'
          is_essential: true
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'number'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(2, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'cell_indices'
          short_name: 'idx'
          is_essential: false
          formats:
            # count
            - ValueFormat:
              type: 'Value'
              sub_type: 'number'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(3, content);
                  return Var(true);
                '''

            # index list
            - SequenceFormat:
              min_count:  1
              max_count: -1
              elements:
                - ElementFormat:
                  formats:
                    - ValueFormat:
                      type: 'Value'
                      sub_type: 'number'
                      on_load:
                        '''{(
                              FormatContext* ctx,
                              shared_ptr<NodeLoadable> loadable,
                              shared_ptr<Node> node,
                              shared_ptr<Content> content
                            )

                          auto self = dpc<Macro>(loadable);
                          unlikely (self->params.get(3) == null)
                            self->params.set(3, make_shared<Sequence>(content));


                          auto seq = dpc<Sequence>(self->params.get(3));
                          seq->add(content);
                          return Var(true);
                        '''
        - AttributeFormat:
          full_name: 'cell_duration_frames'
          short_name: 'frm'
          is_essential: false
          formats:
            # same frame
            - ValueFormat:
              type: 'Value'
              sub_type: 'number'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(4, content);
                  return Var(true);
                '''

            # frame list
            - SequenceFormat:
              min_count:  1
              max_count: -1
              elements:
                - ElementFormat:
                  formats:
                    - ValueFormat:
                      type: 'Value'
                      sub_type: 'number'
                      on_load:
                        '''{(
                              FormatContext* ctx,
                              shared_ptr<NodeLoadable> loadable,
                              shared_ptr<Node> node,
                              shared_ptr<Content> content
                            )

                          auto self = dpc<Macro>(loadable);
                          unlikely (self->params.get(4) == null)
                            self->params.set(4, make_shared<Sequence>(content));


                          auto seq = dpc<Sequence>(self->params.get(4));
                          seq->add(content);
                          return Var(true);
                        '''
        - AttributeFormat:
          full_name: 'sampler'
          short_name: 'sam'
          is_essential: false
          formats:
            - ValueFormat:
              type: 'Object'
              sub_type: 'Sampler'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(5, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'horizontal_align'
          short_name: 'hor'
          is_essential: false
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(6, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'vertical_align'
          short_name: 'ver'
          is_essential: false
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(7, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'image_size'
          short_name: 'siz'
          is_essential: true
          formats:
            - ValueFormat:
              type: 'Sequence'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(8, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'material'
          short_name: 'mat'
          is_essential: false
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(9, content);
                  return Var(true);
                '''
  on_call:
    '''{(
          shared_ptr<Node> node,
          shared_ptr<Content> content,
          shared_ptr<Macro> self
        )

      // get params
      auto& mac_params = self->params;

      auto tex_cont = mac_params.get(0);

      auto row_cnt = mac_params.get(1)->asValue<uint>();
      auto col_cnt = mac_params.get(2)->asValue<uint>();

      auto cell_indices_cont         = mac_params.get(3);
      auto cell_duration_frames_cont = mac_params.get(4);
      auto sam_cont                  = mac_params.get(5);
      auto hor_cont                  = mac_params.get(6);
      auto ver_cont                  = mac_params.get(7);
      auto siz_cont                  = mac_params.get(8);
      auto mat_cont                  = mac_params.get(9);


      // make result
      auto result = make_shared<Sequence>(content);

      CellIndexIterator_  idx_itr(cell_indices_cont, row_cnt, col_cnt);
      CellDurFrmIterator_ frm_itr(cell_duration_frames_cont, idx_itr.size());
      for (auto idx=idx_itr.step(); idx>=0; idx=idx_itr.step()) {
        /// make cell
        auto cell = make_shared<Map>(content);

        // frm
        cell->add("frm", make_shared<Value>(Var(frm_itr.step()), content));


        // img
        auto img = make_shared<Map>(content);
        img->add("tex", tex_cont);

        unlikely (sam_cont != null)
          img->add("sam", sam_cont);

        unlikely (hor_cont != null)
          img->add("hor", hor_cont);

        unlikely (ver_cont != null)
          img->add("ver", ver_cont);

        unlikely (siz_cont != null)
          img->add("siz", siz_cont);

        auto rgn = make_shared<Sequence>(content);
        auto row_i = idx / row_cnt;
        auto col_i = idx % row_cnt;
        rgn->add(make_shared<Value>(Var((real)col_i / (real)col_cnt), content));
        rgn->add(make_shared<Value>(Var((real)row_i / (real)row_cnt), content));
        rgn->add(make_shared<Value>(Var(REAL(1.0)   / (real)col_cnt), content));
        rgn->add(make_shared<Value>(Var(REAL(1.0)   / (real)row_cnt), content));
        img->add("rgn", rgn);

        unlikely (mat_cont != null)
          img->add("mat", mat_cont);

        cell->add("img", make_shared<Object>("Image", img, content));


        /// add cell
        result->add(make_shared<Object>("Cell", cell, content));
      }

      return Var(dpc<Content>(result));
    '''

  hip_part:
    '''{
      namespace {
        CellIndexIterator_::CellIndexIterator_ (sp<Content> const& cont, uint row_cnt, uint col_cnt)
        :content_(cont)
        {
          next_idx_ = 0;

          likely (content_ == null)
            content_type_ = ContentType::DEFAULT;
          else if (dpc<Value>(content_) != null)
            content_type_ = ContentType::COUNT;
          else if (dpc<Sequence>(content_))
            content_type_ = ContentType::INDEX_LIST;
          else
            LOG_ERR("unhandled content type --- %u", content_->type());


          index_list_.clear();
          switch (content_type_) {
            case ContentType::DEFAULT:
              for (int i=0; i<row_cnt*col_cnt; ++i)
                index_list_.push_back(i);
              break;

            case ContentType::COUNT: {
              auto size = content_->asValue<int>();
              for (int i=0; i<size; ++i)
                index_list_.push_back(i);
              break;
            }

            case ContentType::INDEX_LIST: {
              auto seq = dpc<Sequence>(content_);
              for (int si=0; si<seq->size(); ++si)
                index_list_.push_back(seq->get(si)->asValue<int>());
              break;
            }
          }
        }


        int CellIndexIterator_::step () {
          unlikely (next_idx_ >= index_list_.size())
            return -1;

          auto result = index_list_[next_idx_];
          next_idx_ += 1;
          return result;
        }


        size_t CellIndexIterator_::size () const {
          return index_list_.size();
        }




        CellDurFrmIterator_::CellDurFrmIterator_ (sp<Content> const& cont, size_t cell_cnt)
        :content_(cont)
        {
          next_idx_ = 0;

          likely (content_ == null)
            content_type_ = ContentType::DEFAULT;
          else if (dpc<Value>(content_) != null)
            content_type_ = ContentType::FRAME;
          else if (dpc<Sequence>(content_))
            content_type_ = ContentType::FRAME_LIST;
          else
            LOG_ERR("unhandled content type --- %u", content_->type());


          frame_list_.clear();
          switch (content_type_) {
            case ContentType::DEFAULT:
              for (int i=0; i<cell_cnt; ++i)
                frame_list_.push_back(1);
              break;

            case ContentType::FRAME: {
              auto frame = content_->asValue<uint>();
              for (int i=0; i<cell_cnt; ++i)
                frame_list_.push_back(frame);
              break;
            }

            case ContentType::FRAME_LIST: {
              auto seq = dpc<Sequence>(content_);
              for (int si=0; si<seq->size(); ++si)
                frame_list_.push_back(seq->get(si)->asValue<uint>());
              break;
            }
          }
        }


        uint CellDurFrmIterator_::step () {
          unlikely (next_idx_ >= frame_list_.size())
            return 1;

          auto result = frame_list_[next_idx_];
          next_idx_ += 1;
          return result;
        }
      }
    '''
