MacroFormat:
  full_name: 'Sprite.makeCellsBySheet'
  short_name: 'sprite.makeCellsBySheet'
  aliases: ['sprite.cellsBySheet']
  include_part:
    '''{
      #include <game_component/object/game_object.h>
      #include <view/image_view/image_view_def.h>
      #include <view/sprite_view/sprite_view_def.h>
      #include <view/view.h>
    '''

  neck_part:
    '''{
      class CellIndexIterator_ {
      public: // inner types
        enum class ContentType {
          NULL,
          COUNT,
          INDEX_LIST,
        };


      public: // methods
        CellIndexIterator_ (sp<Content> const& cont, uint row_cnt, uint col_cnt);

        int step ();


      private: // vars
        sp<Content> content_;

        ContentType content_type_;
        int next_idx_;
        int size_;
      };


      class CellDurFrmIterator_ {
      public: // methods
        CellDurFrmIterator_ (sp<Content> const& cont);

        sp<Content> step ();


      private: // vars
        sp<Content> content_;
      };
    '''

  formats:
    - MapFormat:
      attributes:
        - AttributeFormat:
          full_name: 'sheet_texture_path'
          short_name: 'tex'
          is_essential: true
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(0, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'row_count'
          short_name: 'row'
          is_essential: true
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'number'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(1, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'col_count'
          short_name: 'col'
          is_essential: true
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'number'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(2, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'cell_indices'
          short_name: 'idx'
          is_essential: false
          formats:
            # count
            - ValueFormat:
              type: 'Value'
              sub_type: 'number'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(3, content);
                  return Var(true);
                '''

            # index list
            - SequenceFormat:
              min_count:  1
              max_count: -1
              elements:
                - ElementFormat:
                  formats:
                    - ValueFormat:
                      type: 'Value'
                      sub_type: 'number'
                      on_load:
                        '''{(
                              FormatContext* ctx,
                              shared_ptr<NodeLoadable> loadable,
                              shared_ptr<Node> node,
                              shared_ptr<Content> content
                            )

                          auto self = dpc<Macro>(loadable);
                          unlikely (self->params.get(3) == null)
                            self->params.set(3, make_shared<Sequence>(content));


                          auto seq = dpc<Sequence>(self->params.get(3));
                          seq->add(content);
                          return Var(true);
                        '''
        - AttributeFormat:
          full_name: 'cell_duration_frames'
          short_name: 'frm'
          is_essential: false
          formats:
            # same frame
            - ValueFormat:
              type: 'Value'
              sub_type: 'number'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(4, content);
                  return Var(true);
                '''

            # frame list
            - SequenceFormat:
              min_count:  1
              max_count: -1
              elements:
                - ElementFormat:
                  formats:
                    - ValueFormat:
                      type: 'Value'
                      sub_type: 'number'
                      on_load:
                        '''{(
                              FormatContext* ctx,
                              shared_ptr<NodeLoadable> loadable,
                              shared_ptr<Node> node,
                              shared_ptr<Content> content
                            )

                          auto self = dpc<Macro>(loadable);
                          unlikely (self->params.get(4) == null)
                            self->params.set(4, make_shared<Sequence>(content));


                          auto seq = dpc<Sequence>(self->params.get(4));
                          seq->add(content);
                          return Var(true);
                        '''
        - AttributeFormat:
          full_name: 'sampler'
          short_name: 'sam'
          is_essential: false
          formats:
            - ValueFormat:
              type: 'Object'
              sub_type: 'Sampler'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(5, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'horizontal_align'
          short_name: 'hor'
          is_essential: false
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(6, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'vertical_align'
          short_name: 'ver'
          is_essential: false
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(7, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'image_size'
          short_name: 'siz'
          is_essential: true
          formats:
            - ValueFormat:
              type: 'Sequence'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(8, content);
                  return Var(true);
                '''
        - AttributeFormat:
          full_name: 'material'
          short_name: 'mat'
          is_essential: false
          formats:
            - ValueFormat:
              type: 'Value'
              sub_type: 'string'
              on_load:
                '''{(
                      FormatContext* ctx,
                      shared_ptr<NodeLoadable> loadable,
                      shared_ptr<Node> node,
                      shared_ptr<Content> content
                    )

                  auto self = dpc<Macro>(loadable);
                  self->params.set(9, content);
                  return Var(true);
                '''
  on_call:
    '''{(
          shared_ptr<Node> node,
          shared_ptr<Content> content,
          shared_ptr<Macro> self
        )

      // get params
      auto& mac_params = self->params;

      auto tex_cont = mac_params.get(0);

      auto row_cnt = mac_params.get(1)->asValue<uint>();
      auto col_cnt = mac_params.get(2)->asValue<uint>();

      auto cell_indices_cont         = mac_params.get(3);
      auto cell_duration_frames_cont = mac_params.get(4);
      auto sam_cont                  = mac_params.get(5);
      auto hor_cont                  = mac_params.get(6);
      auto ver_cont                  = mac_params.get(7);
      auto siz_cont                  = mac_params.get(8);
      auto mat_cont                  = mac_params.get(9);


      // make result
      auto result = make_shared<Sequence>(content);

      CellIndexIterator_  idx_itr(cell_indices_cont, row_cnt, col_cnt);
      CellDurFrmIterator_ frm_itr(cell_duration_frames_cont);
      for (auto idx=idx_itr.step(); idx>=0; idx=idx_itr.step()) {
        /// make cell
        auto cell = make_shared<Map>(content);

        // frm
        cell->add("frm", frm_itr.step());


        // img
        auto img = make_shared<Map>(content);
        img->add("tex", tex_cont);

        unlikely (sam_cont != null)
          img->add("sam", sam_cont);

        unlikely (hor_cont != null)
          img->add("hor", hor_cont);

        unlikely (ver_cont != null)
          img->add("ver", ver_cont);

        unlikely (siz_cont != null)
          img->add("siz", siz_cont);

        auto rgn = make_shared<Sequence>(content);
        auto row_i = idx / row_cnt;
        auto col_i = idx % row_cnt;
        rgn->add(make_shared<Value>(Var((real)col_i / (real)col_cnt), content));
        rgn->add(make_shared<Value>(Var((real)row_i / (real)row_cnt), content));
        rgn->add(make_shared<Value>(Var(REAL(1.0)   / (real)col_cnt), content));
        rgn->add(make_shared<Value>(Var(REAL(1.0)   / (real)row_cnt), content));
        img->add("rgn", rgn);

        unlikely (mat_cont != null)
          img->add("mat", mat_cont);

        cell->add("img", img);


        /// add cell
        result->add(cell);
      }

      return Var(dpc<Content>(result));
    '''

  hip_part:
    '''{
        CellIndexIterator_::CellIndexIterator_ (sp<Content> const& cont, uint row_cnt, uint col_cnt)
        :content_(cont),
         row_cnt_(row_cnt),
         col_cnt_(col_cnt)
        {
          next_idx_ = 0;

          likely (content_ == null)
            content_type_ = ContentType::NULL;
          else if (dpc<Value>(content_) != null)
            content_type_ = ContentType::COUNT;
          else if (dpc<Sequence>(content_))
            content_type_ = ContentType::INDEX_LIST;
          else
            LOG_ERR("unhandled content type --- %u", content_->type());


          switch (content_type_) {
            case ContentType::NULL:
              size_ = row_cnt_ * col_cnt_;
              break;

            case ContentType::COUNT:
              break;

            case ContentType::INDEX_LIST:
              break;
          }
        }


        int CellIndexIterator_::step () {
          likely (content_ == null)
            return 1;
        }




        CellDurFrmIterator_::CellDurFrmIterator_ (sp<Content> const& cont)
        :content_(cont)
        {
        }


        sp<Content> CellDurFrmIterator_::step () {
        }
    '''
